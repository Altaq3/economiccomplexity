---
title: "How to use this package"
author: "Mauricio Vargas"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
bibliography: ../inst/REFERENCES.bib
vignette: >
  %\VignetteIndexEntry{How to use this package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, cache = FALSE, echo = FALSE, message = FALSE, warning = FALSE, tidy = FALSE}
knitr::opts_chunk$set(eval = TRUE, message = FALSE, warning = FALSE)
```

# Basic trade example

## Package data

I'll use this demo dataset to illustrate the essential usage of the functions within this package:

```{r}
library(economiccomplexity)

world_trade_2017
```

## Revealed comparative Advantage (RCA)

You can obtain RCA with `revealed_comparative_advantage()`:
```{r}
rca <- revealed_comparative_advantage(
  data = world_trade_2017, 
  c = "reporter_iso",
  p = "product_code", 
  v = "export_value_usd"
)

rca[1:5,1:5]
```

And also you can obtain it in tabular version:
```{r}
rca_tbl <- revealed_comparative_advantage(
  data = world_trade_2017, 
  c = "reporter_iso",
  p = "product_code",
  v = "export_value_usd",
  tbl_output = T
)

rca_tbl
```

Another possibility, *not used to build networks from bipartite relations*, is to obtain RCA as a matrix or tibble without discretization:

```{r}
rca_decimal <- revealed_comparative_advantage(
  data = world_trade_2017,
  c = "reporter_iso",
  p = "product_code",
  v = "export_value_usd",
  tbl_output = F,
  discrete = F
)

rca_decimal[1:5,1:5]
```

```{r}
rca_decimal_tbl <- revealed_comparative_advantage(
  data = world_trade_2017,
  c = "reporter_iso",
  p = "product_code",
  v = "export_value_usd",
  tbl_output = T,
  discrete = T
)

rca_decimal_tbl
```

## Complexity Measures

You can compute both Economic Complexity Index (ECI) and Product Complexity Index (PCI) by using `complexity_measures()`. The calculations methods are *reflections*, *eigenvalues* and *fitness* (default). See [@atlas2014] and [@measuringcomplexity2015] for the methodological details.

```{r}
complexity_measures_reflections <- complexity_measures(
  rca, 
  method = "reflections", 
  tbl_output = T
)

complexity_measures_reflections$economic_complexity_index
complexity_measures_reflections$product_complexity_index
```

```{r}
complexity_measures_eigenvalues <- complexity_measures(
  rca,
  method = "eigenvalues",
  tbl_output = T
)

complexity_measures_eigenvalues$economic_complexity_index
complexity_measures_eigenvalues$product_complexity_index
```

```{r}
complexity_measures_fitness <- complexity_measures(
  rca,
  method = "fitness", 
  tbl_output = T
)

complexity_measures_fitness$economic_complexity_index
complexity_measures_fitness$product_complexity_index
```

## Proximity

Proximity matrices are used to create both country-country and product-product networks. Using `proximity_matrices()` is straightforward:
```{r}
proximity <- proximity_matrices(
  rca,
  diversity = complexity_measures_fitness$diversity,
  ubiquity = complexity_measures_fitness$ubiquity
)

proximity$countries_proximity[1:5,1:5]
proximity$products_proximity[1:5,1:5]
```

## Networks

The `proximity_networks()` function is designed to use `igraph` for the internal computations and also to pass proximity-based networks to `igraph`, `ggraph` or export to Cytoscape by saving the output as csv/tsv.

To create some reduced networks I'll use a high proximity cutoff:

```{r}
networks <- proximity_networks(
  proximity$countries_proximity,
  proximity$products_proximity,
  c_cutoff = 0.3,
  p_cutoff = 0.6,
  tbl_output = T
)

networks$countries_network
networks$products_network
```

Just a basic example with `igraph`:
```{r}
library(igraph)

set.seed(1810)

countries_network <- graph_from_data_frame(networks$countries_network, directed = F)

plot(
  countries_network, 
  layout = layout_with_kk,
  vertex.size = 5,
  vertex.color = "#a8a8a8",
  vertex.label.dist = 1,
  vertex.label.color = "black"
)
```

# References
